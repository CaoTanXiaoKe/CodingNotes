# 线程安全与同步
**一个线程所特有的数据:** 线程ID, 栈, 栈指针，通用目的寄存器，程序计数器，条件码，信号屏蔽字，线程优先级。 

## 线程安全
- **可重入函数：** 当它们被多个线程调用时，不会引用任何共享数据。 可重入函数是线程安全函数的真子集。 

### 四类(不相交的)线程不安全函数：
1. 不保护共享变量的函数。 ——> 解决方法： 加锁同步。 
2. 保持跨越多个调用状态的函数。例如 `rand()`。 ——> 解决方法： 重写，使它不再使用任何 static 数据， 而是依靠调用者在参数中传递状态信息。 
3. 返回指向静态变量的指针的函数。 如 `ctime()`。 ——> 解决方法： 加锁—拷贝。
4. 调用线程不安全的函数。 ——> 解决方法： 使用上面三种方法，使之线程安全。 

### 死锁:
- 死锁定义： 指的是一组 线程/进程被阻塞了，等待一个永远不会为真的条件。 
- 死锁条件： 互斥条件， 不可抢占条件， 申请持有条件，循环等待条件。 
- 防止死锁： 预防死锁， 避免死锁， 检测与恢复。 

程序死锁的原因有很多，要避免死锁一般而言是很困难的。 然而，当使用二元信号量（或互斥锁）来实现互斥时，可以用以下方法避免死锁。 
> **互斥锁加锁顺序规则:** 如果对于程序中， 每对互斥锁(s, t)，给所有的锁分配一个全序，每个线程按照这个顺序来请求锁，并按照逆序来释放，那么这个程序就是无死锁的。 

## 线程同步
1. 信号量： 信号量就是一个计数器，不过其加减操作都是原子操作。 原子操作是内核用一条计算机指令 `CAS: compare and swap(set)` 进行实现的, 由于是一条计算机指令，所以不会出现 ABA问题。 
2. 互斥量： 互斥量从本质上来说是一把锁，在访问共享资源前对互斥量进行设置（加锁），在访问完成后释放（解放）互斥量。相当于二值信号量。 
3. 条件变量： 条件变量给多个线程提供了一个会合的场所，条件本身是由互斥量保护的。条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生，进而调度对共享资源的访问。 
4. 读写锁：与互斥量类似，不过读写锁允许更高的并行性。互斥量要么是锁住状态，要么就是不加锁状态，而且一次只有一个线程可以对其加锁。读写锁可以有 3 种状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。 一次只有一个线程可以占有写模式下的读写锁，但是多个线程可以同时占有读模式下的读写锁。 
**读写锁非常适合于对于数据结构读的次数远大于写的情况。**
5. 自旋锁：