## 虚拟存储器总结

**虚拟存储器** 是主存的抽象。 虚拟存储器是硬件异常，硬件地址翻译，主存，磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的，一致的和私有的地址空间。通过一个很清晰的机制，虚拟存储器提供了三个重要的能力：
1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。 
2. 它为每个进程提供了一致的地址空间从而简化了存储器管理。 
3. 它保护了每个进程的地址空间不被其他进程破坏。 


### 虚拟寻址
**处理器通过虚拟寻址的方式访问主存，虚拟地址在被送到存储器之前会被 MMU(存储器管理单元)根据页表转换成物理地址，进而访问物理地址所指向的数据对象。**

### 虚拟地址空间
虚拟地址空间，就是一个非负整数地址的有序集合。 32位系统中这个集合的大小是 2^32(4G)， 64位系统中这个集合的大小是2^48 (256T)。虚拟地址空间的概念说明数据对象和它们的地址是分离的，也就是说一个数据对象可以对应多个虚拟地址 —— 这一点十分重要。

### 虚拟存储器
概念上而言，虚拟存储器(VM)被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。 每个字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。虚拟存储器系统把虚拟存储器分割成虚拟页，物理存储器也被分割成等大小的物理页（在Linux中页的大小是 4K）。 物理存储器作为虚拟存储器的缓存，它们之间数据传输的基本单元就是页。 

在任何时刻，虚拟页面的集合都被分成三个不相交的子集。
- 未分配的： 虚拟存储器还未分配（或创建）的页。未分配的页没有任何数据和它们相关联，因此也就不占用任何磁盘空间。 
- 缓存的： 当前缓存在物理存储器中的已分配页。
- 未缓存的： 没有缓存在物理存储器中的已分配页。 

### 页表
虚拟存储器是通过页表映射到物理页的。 
页表就是一个页表条目的数组。每个页表条目的前半部分是一些控制位和标志位，如控制用户访问权限，可读，可写，是否缓存了的。如果缓存了，后面的地址位存储的是物理页的首地址，如果未缓存，后面存储的是虚拟页的首地址。 

如果访问未被缓存的虚拟页，会发生缺页异常，引起页面调度。现代的系统都是**按需页面调度的方式**，也就是一直等到不命中发生时，才换入页面。 

### 虚拟存储器系统的作用
1. 操作系统为每个进程提供了一个独立的页表，因而每个进程都有一个独立的虚拟地址空间。 
2. 简化连接： 独立的地址空间允许每个进程的存储器映像使用相同的基本格式。而不管代码和数据实际存放在物理存储器的何处。这样的一致性允许连接器生成全链接的可执行文件。这些可执行文件是独立于物理存储器中的代码和数据的最终位置的。 
3. 简化加载： 在程序加载时，Linux加载器分配虚拟页的一些片（各个段内的虚拟页面是连续的），将这些虚拟页面标记为未被缓存的，将页表条目指向目标文件中适当的位置。加载器从不实际拷贝任何数据从磁盘到存储器，在每个页初次被引用时，虚拟存储器系统会按照需要自动地调入数据页。 
4. 简化共享： 独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。 
5. 简化存储器分配。当一个运行在用户进程中的程序要求额外的堆空间时，操作系统分配一个适当的数字的连续虚拟存储器页面（例如K个），并且将它们映射到物理存储器中任意位置的 K 个任意物理页面。用于页表的工作方式，操作系统没有必要分配 K 个连续的物理存储器页面。页面可以随机地分散在物理存储器中。 

### Linux 段页式管理
