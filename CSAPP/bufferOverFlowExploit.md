## 存储器的越界引用和缓冲区溢出

CSAPP（第三章: 程序的机器级表示）

### 缓冲区溢出所利用的 C 语言的特点：
1. C 对于数组引用不进行任何边界检查。
2. C 中局部变量和状态信息（保存的寄存器值和返回地址）都存放在栈中。

这两种情况结合到一起就可能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行ret指令时，就会出现很严重的错误。 

由于栈的组织方式，寄存器值和返回地址放在栈的底部（低地址区域）， 当在栈中分配某个字节的字符串，但是字符串的长度超过了为数组分配的空间，就可能会破坏状态信息（例如保存的寄存器值和返回地址）。 这种状态破坏称为**缓冲区溢出（buffer overflow）**。 

### 缓冲区溢出攻击
缓冲区溢出攻击的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种常见的通过计算机网络攻击系统安全的方法。通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为**攻击代码（exploit code）**, 另外， 还有一些字节会用一个指向攻击代码的指针覆盖返回地址。 那么，执行 ret 指令的效果就是跳转到攻击代码。 

一种攻击形式，攻击代码会使用系统调用启动一个外壳程序，给攻击者提供一组操作系统函数。 另一个攻击形式是，攻击代码会执行一些未授权的任务，然后修复对栈的破坏，然后第二次执行ret指令，（表面上）正常返回给调用者。


### 对抗缓冲区溢出
1. **栈随机化：** 为了在系统中插入攻击代码，攻击者不但要求插入代码，还需要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。 由于过去运行同样程序和操作系统版本的系统来说，它们的栈的位置是相当固定的。因此如果攻击者可以确定一个常见的Web服务器所使用的栈空间，就可以设计一个在许多机器上都能实施的攻击，这种现象常称为**安全单一化（security monoculture）**。 

栈随机化的思想使得栈的位置在程序每次运行时都有变化。 因此，即使许多机器都运行相同的代码，它们的栈地址都是不同的。 实现方式是：程序开始时，在栈上分配一段 0 ~ n 字节之间的随机大小的空间。 （在32位Linux 上，范围大小大约是 2^23; 在64位Linux上，范围大小大约是2^32）。

> 附注：在Linux系统中，栈随机化已经变成了标准行为。它是更大一类技术中的一种，这类技术称为**地址空间布局随机化（Address-Space Layout Randomization）**, 或者简称 ASLR。 采用 ASLR, 每次运行时程序的不同部分，包含程序代码，库代码，栈，全局变量和堆数据，都会被加载到存储器的不同区域。这就意味着在一台机器上运行一个程序，与其他机器上运行同样的程序，它们的地址映射大相径庭。这样才能对抗某些形式的攻击。 

2. **栈破坏检测:** 计算机的第二道防线是能够检测到何时栈已经破坏。现在的GCC版本在产生的代码中加入了一种**栈保护者（stack protector）**机制，用来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的**金丝雀（canary）**值。这个金丝雀值也称为**哨兵值（guard value）**, 是在程序每次运行时随机产生的。 因此，攻击者没有简单的办法能够知道它是什么。 在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个0操作或者该函数调用的某个函数的某个操作改变了。如果是，那么程序异常中止。 

3. **限制可执行代码区域：**最后一招是消除攻击者向系统中插入可执行代码的能力。 一种方法是限制那些能够存放可执行代码的存储器区域。在典型的程序中，只有保存编译器产生的代码的那部分存储器才需要是可执行的。 其他部分可以被限制为只读和写。 
AMD 为它的 64 位处理器的内存保护引入了“NX”(No-eXecute, 不执行)位， 将读和执行访问模式分开，并且Intel也跟进了。有了这个特性，栈可以被标记为可读和可写，但是不可执行，检查页是否可执行由硬件来完成，效率上没有损失。 