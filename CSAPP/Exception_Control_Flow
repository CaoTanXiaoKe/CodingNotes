## 异常控制流(Exception Control Flow)
现代操作系统通过使控制流发生突变来对一些情况做出反应（如硬件的定时信号，程序向磁盘请求数据，子进程终止时父进程要得到通知）。一般而言，我们把这些突变称为**异常控制流(Exception Control Flow)**。 异常控制流发生在计算机系统的各个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文转换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送信号到另一个进程，而接收者会将控制转移到它的一个信号处理程序。一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。 

ETC 是计算机系统实现并发的基本机制。 中断应用应用程序，进程和线程（它们的执行在时间上是重叠的）执行的异常处理程序和中断应用程序执行的信号处理程序都是在运行中并发的例子。 

非本地跳转是一种应用层 ECF, 在 C 中是通过 setjmp 和 longjmp 函数提供的。 理解这些低级函数将帮助我们理解高级软件异常如何得以实现。 

应用和操作系统的交互都是围绕着 ECF 进行的。这里是存在于一个计算机系统中所有层次上的各种形式的 ECF。 

- 异常： 异常位于硬件和操作系统交界的部分。
- 系统调用：它们是为应用程序提供操作系统入口的异常。 
- 描述进程和信号： 它们位于应用和操作系统的交界之处。 
- 非本地跳转： 这时 ECF 的一种应用层形式。 

在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做**异常表(exception table)** 的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序(**异常处理程序(exception handler)**)


#### 异常的类别

1. 中断。 中断是一部发生的，是来自处理器外部的I/O设备的信号的结果，硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。 


2. 陷阱和系统调用。 陷阱是有意的异常，是执行一条指令的结果。陷阱最重要的用途是在用户进程和内核之间提供一个像过程一样的接口，叫做**系统调用**。 

3. 故障。 故障由错误情况引起，它可能能够被故障处理程序修正。 

4. 终止。 

#### 程序与进程

新创建的子进程几乎但不完全与父进程相同。 子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份拷贝，包括文本，数据和bss段，堆以及用户栈。 子进程还获得与父进程任何打开文件描述符相同的拷贝，这就意味着当父进程调用 fork 时, 子进程可以读写父进程中打开的任何文件。 父进程和新创建的子进程之间最大的区别在于它们有不同的PID. 

子进程和父进程谁先执行依赖于内核相关的调度决策。在一次 fork  调用之后，有些内核调度子进程先运行，而有些内核调度父进程先运行。 一般而言，做为程序员，我们绝不能对不同进程中指令的交替执行做任何假设。 

execve 函数加载并运行可执行目标文件 filename， 且带参数列表 argv 和环境变量列表 envp. 只有当出现错误时，例如找不到 filename, execve 才会返回到调用程序。 所以， 与 fork 一次调用返回两次不同， execve 调用一次并从不返回。 

fork 函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。 execve 函数在当前进程的上下文中加载并运行一个新的程序。它会覆盖当前进程的地址空间，但并没有创建一个新进程。新的程序依然有相同的 PID, 并且继承了调用 execve 函数时已打开的所有文件描述符。  

#### 信号
一个信号就是一个小消息，它通知进程系统中发生了一个某种类型的事件。 

- 发送信号： 内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有两个原因：1)内核检测到一个系统事件，比如被零除错误或者子进程终止。2）一个进程调用了 kill 函数。 显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。 

- 接收信号： 当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。 进程可以忽略这个信号，终止或者通过执行一个称为**信号处理程序(signal handler)**的用户层函数捕获这个信号。 

一个只发出而没有被接收的信号叫做**待处理信号(pending signal)**在任何时候，一种类型至多会有一个待处理信号。 

一个待处理信号最多只能被接收一次。内核为每个进程在 pending **位向量** 中维护着待处理信号的集合，而在blocked位向量中维护着被阻塞信号集合。 只要传送了一个类型为 k 的信号，内核就会设置 pending 中的第 k 位，而只要接收了一个类型内 k 的信号， 内核就会清除 pending 中的第 k 位。 

外壳为每个作业创建一个独立的进程组。

输入 ctrl-c 会导致内核向每个前台进程组中的成员发送一个 SIGINT 信号 (而不是向 shell 发送)。 ctrl-z 和 SIGTSP 信号也是类似。 

当内核从一个异常处理程序返回，准备将控制传递给进程 p 时， 它会检查进程 p 的未被阻塞的待处理信号集合（pending&~blocked）. 如果这个集合为空(通常情况下)，那么内核将控制传递到 p 的逻辑控制流中的下一条指令。 

通过把处理程序的地址传递到 signal 函数从而改变默认行为，这叫做**设置信号处理程序(installing the handler)。** 调用信号处理程序称为**捕获信号**。 执行信号处理程序称为处理信号。 

#### 信号处理程序

- 待处理信号被阻塞
- 待处理信号不会排队等待
- 系统调用可以被中断

由于待处理信号不会排队等待，由此得到的重要教训是，不可以用信号来对其他进程中发生的事件计数。 

setjmp 函数只被调用一次， 但返回多次：一次是当第一次调用 setjmp, 而调用环境保存在缓冲区 env 中时；一次是为每个相应的 longjmp 调用。 另一方面，longjmp 函数被调用一次，但从不返回。 

非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。 如果在一个深层嵌套的函数调用中发现了一个错误，我们可以使用非本地跳转直接返回到一个普通的本地化的错误处理程序，而不是费力地解开调用栈。 

非本地跳转的另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。 

#### 总结

异常控制流（ECF）发生在计算机系统的各个层次， 是计算机系统中提供并发的基本机制。 在硬件层，异常是由处理器中的事件触发的控制流中的突变。 控制流传递给一个软件处理程序，该处理程序进行一些处理，然后返回控制给被中断的控制流。 

有四种不同类型的异常： 中断，故障， 终止和陷阱。 当一个外部 I/O 设备，例如定时器芯片或者一个磁盘控制器，设置了处理器芯片上的中断引脚时，（对于任意指令）中断会异步发生。 一条指令的执行可能导致故障和终止同时发生。 故障处理程序会重启故障指令，而终止指令从不将控制返回给被中断的流。 最后，陷阱就像是用来实现向应用提供到操作系统代码的受控的入口点的系统调用的函数调用。 

在操作系统层，内核用 ECF 提供进程的基本概念。 进程提供给应用两个重要的抽象： 1) 逻辑控制流，它提供给每一个流一个假象，好像它是在独占地使用处理器， 2）私有地址空间，它提供给每个程序一个假象， 好像它是在独占地使用主存。 

在操作系统和应用程序接口处，应用程序可以创建子进程， 等待它们的子进程停止或者终止，运行新的程序，以及捕获来自其他进程的信号。 信号处理的语义是微妙的，并且随系统不同而不同。 然而， 在与 Posix 兼容的系统上存在着一些机制， 允许程序清除地指定期望的信号处理语义。 

最后，在应用层， C 程序可以使用非本地跳转来规避正常的 调用/返回栈规则， 并且直接从一个函数分支到另一个函数。 







