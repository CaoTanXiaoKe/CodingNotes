## 连接器

输入的可重定位的目标文件是由各种不同的代码块组成，链接器将这些块连接起来，确定被连接块的运行位置，并且修改代码和数据块中的各种位置。

1. 理解局部变量和全局变量的区别是什么？ 程序函数的作用域是如何实现的？
2. 静态链接库，共享库，动态链接的区别：从传统静态链接到加载时的共享库的动态链接，以及到运行时的共享库的动态链接。 

外壳程序调用操作系统中一个叫做**加载器**的函数，它拷贝可执行文件p中的代码和数据到存储器，然后将控制转移到这个程序的开头。

#### 连接器如何解析多重定义的全局符号
在编译时，编译器向汇编器输出每个全局符号，或者强或者弱，而汇编器把这个信息隐含的编码在可重定位目标符号表里。函数和已初始化的全局变量是强信号，未初始化的全局变量是弱信号。 

根据强弱信号的定义，Unix 链接器使用下面的规则来处理多重定义符号：
- 规则 1：不允许有多个强信号。
- 规则 2：如果有一个强信号和多个弱信号，那么选择强信号。
- 规则 3：如果有多个弱信号，那么从这些弱信号中任意选择一个。 

```cpp
/* foo3.c */
#include <stdio.h>
void f(void);

int x = 9999;

int main()
{
	f();
	printf("x = %d\n", x); 
	return 0; 
}
```

```cpp
/* bar3.c */
int x; 

void f()
{
	x = 666; 
}
```
在 linux 下 执行`gcc foo3.c bar3.c` 进行编译； 执行 `./a.out` 运行；得到结果：

**x = 666**. x = 9999; 被 f函数中 x = 666; 替换了。 

如果 x 有两个弱定义，也会发生相同的事情(规则 3): 实际上，如果当 x 的类型也不一样时，情况会更加糟糕！ 
可以用`GCC-fno-common`这样的选项调用链接器，这个选项会告诉链接器，在遇到多重定义的全局符号时，输出一条警告信息。

#### 与静态库链接

所用的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为**静态库(static library)**,它可以用做链接器的输入。当链接器构造一个输出的可执行文件时，它只拷贝静态库里被应用程序引用的目标模块。

**静态库如何使用静态库解析引用**： 文字很多，理解就好。 记住准则：
- 一般把库放在命令行结尾
- 库之间如果有引用关系，满足拓扑序关系
- 如果需要满足依赖关系，可以在命令行上重复库。

#### 制作自己的静态库

假设写好了两个向量运算函数：`addvec.c` 和 `multvec.c` 
使用命令: `gcc -c addvec.c multvec.c` 和 `ar rcs libvector.a addvec.o multvec.o` 
用一个头文件`vector.h`包含这两个函数的声明
然后就可以在程序（main.c）中使用了： `gcc -static main.c ./libvector.c` 

在链接结束后，程序中的每条指令，全局变量，引用，都有唯一的运行时存储器地址了。

#### 加载器
任何 Unix 程序都可以通过调用 `execve` 函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘拷贝到存储器中，然后通过跳转到程序的第一条指令或**入口点(entry)**来运行该程序。这个将程序拷贝到存储器并运行的过程叫做**加载(loading)。** 


#### 动态链接共享库

制作动态链接库： `gcc -shared -fPIC -o libvector.so addvec.c multvec.c`
静态库解决了许多关于如何让大量相关函数对应用程序可用的问题。 然而，静态库仍然有一些明显的缺点。静态库和所有软件一样，需要定期维护和更新。如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解该库的更新情况，然后显式地将他们的程序与更新了的库重新链接。另一个问题是几乎每个 C 程序都使用标准 I/O 函数，如 `printf` 和 `scanf`。在运行时，这些函数的代码会被复制到每个运行进程的文本段中。在一个运行 50 ~ 100 个进程的典型系统上，这将是对稀缺的存储器系统资源的极大浪费。 

**共享库(shared library)**是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行时，可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来。这个过程称为**动态链接（dynamic linking）**，是由一个叫做**动态链接器（dynamic linker）**的程序来执行的。

#### 总结
链接可以在编译时由静态编译器来完成，也可以在加载时和运行时由动态链接器来完成。 链接器处理称为目标文件的二进制文件，它有三种不同形式：可重定位的，可执行的和共享的。 可重定位的目标文件由静态链接器合并成一个可执行的目标文件，它可以加载到存储器中并执行。共享目标文件（共享库）是在运行时由动态链接器链接和加载的，或者隐含地在调用程序被加载和开始执行时，或者隐含地在调用程序被加载和开始执行时，或者根据需要在程序调用`dlopen`库的函数时。 

链接器的两个主要任务是**符号解析**和**重定位**, 符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，而重定位确定每个符号的最终存储器地址，并修改对那些目标的引用。 

加载器将可执行文件的内容映射到存储器，并运行这个程序。链接器还可能生成部分链接的可执行目标文件，这样的文件中有对定义在共享库的程序和数据的未解析的引用。在加载时，加载器将部分链接的可执行文件映射到存储器，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。 

被编译为位置无关代码的共享库可以加载到任何地方，也可以在运行时被多个进程共享。为了加载，链接和访问共享库的函数和数据，应用程序还可以在运行时使用动态链接器。 
