#### 1. accept返回前连接中止
就在客户端和服务器端的三次握手建立连接后，客户端TCP却发送了一个复位RST(复位)。 在服务器端看来，就在该连接已有TCP排队，等着服务器进程调用accept的时候RST到达。稍后，服务器进程调用 accept. 

解决方案： 再次调用 accept. 

#### 2. 服务器进程中止

- 在进程终止时，作为进程终止处理的部分工作，子进程中所有打开着的文件描述符都被关闭。这就导致向客户发送一个FIN,而客户TCP则相应一个ACK. 这就是TCP连接终止工作的前半部分。 如果此时客户端阻塞在标准输入上，那么应用进程并不能知晓服务器端发送FIN, 在标准输入上输入数据后，这些数据会发送到服务器（这样做是可以的， 服务器端发送FIN，只是表示它不再发送数据）。 服务器TCP接收到来自客户端的数据时，既然先前打开的那个套接字的进程已经终止，于是相应一个RST. 然而客户端看不到这个RST了，在客户端再次调用read时，由于那个阻塞的FIN（EOF），进程就终止了。 

> 当一个进程向某个已收到RST的套接字执行写操作时，内核向该进程发送一个SIGPIPE信号。该信号的默认行为是终止进程。

#### 3. 服务器主机崩溃
如果服务器崩溃后没有重启，当客户端发送请求时它会持续重传分节直到超时。 当客户TCP最终放弃时，会给客户进程返回一个错误。（ETIMEOUT）

#### 4. 服务器崩溃后重启

- 在建立TCP连接后，服务器崩溃，随即重启。 客户端发送数据到服务器主机。当服务器崩溃后重启时，它的TCP丢失了崩溃前的所有连接信息，因此服务器TCP对于所收到的来自客户端的数据分节相应一个RST. 
- 当客户接收到该RST时，客户正阻塞于readline调用，导致该调用返回ECONNRESET错误。 

#### 5. 服务器关机
Unix系统关机时，init进程通常先给所有进程发送SIGTERM信号，等待一段固定的时间，然后给所有仍在运行的进程发送SIGKILL信号。当服务器子进程终止时，其所有打开着的文件描述符都将被关闭，情况和 “1”相同。 