# 网络编程笔记（一）

### TCP 三次握手 与 套接字
1. 服务器必须准备好接受外来的连接。 这通常通过调用  socket, bind 和 listen 这三个函数来完成， 我们称之为**被动打开（passive open）**。 
2. 客户通过调用 connect 发起**主动打开（active open）**. 这导致客户 TCP 发送一个 SYN（同步）分节，它告诉服务器客户将在（待建立的）连接中发送的数据的初始序列号。 通常 SYN 分节不携带数据，其所在 IP数据报只含有一个 IP首部， 一个TCP首部及可能有的TCP选项。(客户：CLOSED --> SYN_SENT ; 服务器：LISTEN --> SYN_RCVD) 
3. 服务器必须确认（ACK）客户的 SYN, 同时自己也得发送一个 SYN 分节， 它含有服务器将在同一个连接中发送的初始序列号。服务器在单个分节中发送SYN和对客户SYN的ACK(确认)。(客户：ESTABLISHED) 
4. 客户必须确认服务器的 SYN.(服务器：ESTABLISHED)

这种交换至少需要 3 个分组， 因此称之为 TCP 的**三路握手（three-way handshake）**  

### TCP 连接终止（四次挥手）
1. 某个应用进程首先调用 close, 我们称该端执行**主动关闭（active close）**, 该端的 TCP 于是发送一个 FIN 分节， 表示数据发送完毕。 (主动端：ESTABLISHED --> FIN_WAIT_1)
2. 接收到这个FIN的对端执行**被动关闭（passive close）**. 这个 FIN 由TCP确认。 它的接收也作为一个文件文件结束符（end-of-file）传递给接收端应用进程（放在已排队等候该应用进程接收的任何其他数据之后）， 因为 FIN 的接收意味着接收端应用进程在相应连接上再无额外数据可接收。(被动端：ESTABLISHED --> CLOSE_WAIT)(主动端收到ACK: FIN_WAIT_1 --> FIN_WAIT_2) 
3. 一段时间后， 接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN.(被动端：CLOSE_WAIT --> LAST_WAIT) 
4. 接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN.(主动端：FIN_WAIT_2 --> TIME_WAIT)

被动关闭端收到主动端的 ACK （LAST_ACK --> CLOSED）

主动端的TIME_WAIT会持续 2MSL(maximum segment lifetime，最长分节生命期)。 
TIME_WAIT状态有两个存在的理由：
- 可靠地实现TCP全双工连接的终止。 
- 允许老的重复分节在网络中消逝。 

既然每个方向都需要一个FIN和一个ACK，因此通常需要 4 个分节。 我们使用限定词“通常”是因为：某些情形下步骤1的FIN随数据一起发送；另外，步骤2和步骤3发送的分节都出自执行被动关闭那一端，有可能被合并成一个分节。 



网络编程中的输入一般都分为两步：
1）等待数据准备好；
2）从内核向进程复制数据；
对于一个套接字上的操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。
第二步就是把数据从内核缓冲区复制到应用缓冲区。

### I/O复用
select 函数，该函数允许进程指示内核等待多个事件中的任何一个发生， 并只有一个或多个事件发生或经历一段指定的时间后才唤醒它。 
也就是说，我们调用select告知内核对哪些描述符（就读，写或异常条件）感兴趣以及等待多长时间。 我们感兴趣的描述符不局限于套接字，任何描述符都可以使用select来测试。  