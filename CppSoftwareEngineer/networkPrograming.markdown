### OSI 的体系结构

#### 七层协议：

```
		7. 应用层
		6. 表示层
		5. 会话层
		4. 运输层
		3. 网络层
		2. 数据链路层
		1. 物理层
```

#### 五层协议：

```
		5. 应用层
		4. 运输层
		3. 网络层
		2. 数据链路层
		1. 物理层
```

#### 五层协议各层的作用
- 应用层： 通过应用进程间的交互来完成特定网络应用。
- 运输层： 负责向两台主机中进程之间的通信提供通用的数据传输服务。
- 网络层： 负责为分组交换网上的不同主机提供通信服务。 
- 数据链路层： 将网络层交下来的 IP数据报组装成帧，在两个相邻结点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 
- 物理层： 在物理层上所传数据单位是比特。 




### TCP 与 UDP

- [TCP/IP复习笔记](https://segmentfault.com/a/1190000004598598)
- [网络编程：TCP初探](http://chenwenke.cn/blog/2017/04/15/unp-tcp/)

#### TCP 常用选项
- MSS 最大报文段长度
- 窗口扩大选项， 尤其适用于长粗型 TCP。
- 时间戳（1）. 用来计算往返时间 RTT。 （2）. 用于处理 TCP 序号超过 2^32的情况，这又称为防止序号绕回。 
- SO_REUSEADDR选项：用于使得一个端口绑定多个IP， 或者 wait_time期间绑定端口。
- SO_KEEPALIVE选项： 给一个 TCP 套接字设置保持存活选项后，如果两个小时内在该套接字上没有数据交换，TCP就自动给对端一个保持存活探测分节。
主要应对：对方主机掉线，电源掉电或系统崩溃。[补充：HTTP的长连接和短连接](http://www.cnblogs.com/cswuyg/p/3653263.html)
- SO_ERROR选项：通过调用 getsockopt 函数获取并清除套接字错误。

### 滑动窗口

### 流量控制与拥塞控制

### HTTP协议

### 套接字可读/可写条件
- 满足下列五个条件中的任何一个时，一个套接字准备好读。 
	1. 该套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小。对这样的套接字执行读操作不会阻塞并将返回一个大于0的值。
	2. 该连接的读半部关闭（也就是接收了FIN的TCP连接）。对这样的套接字的读操作将并不阻塞并返回0（也就是返回EOF）. 
	3. 该套接字是一个监听套接字且已完成的连接数不为0. 对这样的套接字的accept通常不会阻塞。
	4. 其上有一个套接字错误待处理。对这样的套接字的读操作将不阻塞并返回-1（也就是返回一个错误），同时把 errno设置成确切的错误条件。这些待处理错误也可以通过指定 SO_ERROR套接字选项调用 getsockopt 获取并清除。
	5. 在Linux中 假设epoll集合的监听描述符为fd。当epoll监听集合中有文件描述符就绪时，fd可读。

- 满足下列四个条件中的任何一个时，一个套接字准备好写。 
	1. 该套接字发送缓冲区中可用空间字节数大于等于套接字发送低水位标记的当前大小，并且或者该套接字已连接，或者该套接字不需要连接（如UDP套接字）。 
	2. 该套接字的写半部关闭。对这样的套接字的写操作将使内核产生一个 SIGPIPE信号。
	3. 使用非阻塞式 connect 的套接字已建立连接，或者connect已经以失败告终。
	4. 其上有一个套接字错误待处理。对这样的套接字的写操作将不阻塞并返回-1.（也就是一个错误），同时把 errno 设置成确切的错误条件。这些待处理错误也可以通过指定 SO_ERROR套接字选项调用 getsockopt获取并清除。

### 非阻塞 connect
当在一个非阻塞的 TCP 套接字上调用 connect 时， connect 将立即返回一个 EINPROGRESS错误，不过已经发起的TCP三路握手继续进行。我们接着使用 select 检测这个连接或成功或失败的已建立条件。

非阻塞 connect 的用途：
1. 可以把三路握手叠加在其他处理上。 完成一个 connect 要花一个 RTT时间，这段时间可以处理其它的事。 
2. 可以用这个技术同时建立多个连接。
3. 既然使用 select 等待连接的建立，我们可以给 select 指定一个时间限制，使得我们能够缩短 connect 的超时。

必须处理的细节：
1. 尽管套接字是非阻塞的，如果客户端和连接到的服务器在同一台主机上 ，那么当我们调用 connect时，连接通常立刻建立。我们必须处理这种情形。
2. 有关 select 和非阻塞 connect 有以下两个规则：
	1. 当连接成功建立时，描述符变为可写。
	2. 当连接建立遇到错误时，描述符变为即可读又可写。
所以，我们需要调用 getsockopt 并检查套接字上是否存在待处理错误。 另外，如果在调用 select之前有可能连接已经建立并有对端的数据已经到达。这种情况下套接字上没有发生错误，但仍是即可读又可写的。 


### Time_wait 与 SO_REUSADDR 套接字选项
Time_wait 状态存在的理由: （2MSL最大分节生命期）
1. 可靠的实现 TCP 全双工连接的终止。 
2. 允许老的重复分节在网络中消逝。 

值得注意的是，Time_wait并不会占用更多的系统资源，但是可以通过修改内核参数 /etc/sysctl.conf 来达到限制 time_wait 数量的功能。 在 time_wait 期间，端口不可被重新分配使用。

SO_REUSEADDR 套接字选项，能起到以下 4个不同的功用：
1. SO_REUSEADDR 允许启动一个监听服务器并捆绑其众所周知的端口，即使以前建立的将该端口用作它们的本地端口的连接仍存在。 
这个条件通常这样碰到：
	1. 启动一个监听服务器。
	2. 连接请求到达，派生一个子进程来处理这个客户。
	3. 监听服务器终止，但子进程继续为现有连接上的客户提供服务。 
	4. 重启监听服务器。 
2. SO_REUSEADDR 允许在同一个端口上启动同一个服务器的多个实例。
3. SO_REUSEADDR 允许单个进程捆绑同一个端口到多个套接字上，只要每次绑定指定不同的本地IP地址即可。 
4. SO_REUSEADDR 允许完全重复的捆绑；当一个IP地址和端口号已绑定到某个套接字时，如果传输协议支持，同样的IP地址和端口还可以捆绑到另一个套接字上。 一般来说本特性仅支持 UDP套接字。

### UDP调用 connect() 的作用
UDP 调用 connect 没有三路握手过程。（1）内核只是检查是否存在立即可知的错误（例如一个显然不可达的目的地）
。 （2）记录对端的 IP 地址和端口号，然后立即返回到调用进程。

作用：
1. 不需要再为输出操作指定目的IP地址和端口号。 
2. 限制一个已连接 UDP套接字能且仅能与一个对端交换数据报。
3. 由已连接 UDP套接字引发的异步错误会返回给它们所在的进程。而未连接UDP套接字不接收任何异步错误。

#### 一个UDP出于什么愿意会多次调用 connect
1. 指定新的IP地址和端口号。
2. 断开套接字。 

### shutdown 函数
终止网络连接的通常方法是调用 close 函数。 不过 close 函数有两个限制，却可以使用 shutdown 来避免。
1. close 把描述符的引用计数减 1， 仅在该计数变为 0 时，才关闭套接字。 使用 shutdown 可以不管引用计数就激发 TCP 的正常连接终止序列。
2. close 终止读和写两个方向的数据传送。既然 TCP 连接是全双工的，有时候我们需要告知对端我们已经完成了数据发送，即使对端仍有数据要发送给我们。

