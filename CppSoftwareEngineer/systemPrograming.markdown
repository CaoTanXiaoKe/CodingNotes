## RST 与 SIGPIPE

### RST 发生的条件
RST 是 TCP 在发生错误时发送的一种 TCP 分节。 产生 RST 的三个条件是：
1. 目的地为某端口的 SYN 到达，然而该端口上没有正在监听的服务器。 
2. TCP 想取消一个已有连接
3. TCP 接收到一个根本不存在的连接上的分节

### connection reset by peer 和 broken pipe
1. 往一个对端已经 close 的通道写数据的时候，对方的TCP会收到这个报文，并且反馈一个 reset 报文。 当收到 reset 报文的时候，继续做 select 读数据的时候就会抛出 connection reset by peer 的异常。
2. 当第一次往一个对端已经 close 的通道写数据的时候会和上面的情况一样，会收到 reset 报文。当再次往这个socket写数据的时候，就会抛出 Broken pipe 了。 根据 TCP 的约定，当收到 reset包的时候，上层必须做出处理，调用将 socket 文件描述符关闭，其实也意味着 pipe 会关闭，因此会抛出这个顾名思义的异常。 

### SIGPIPE 信号
当第一次往一个对端已经 close 的通道上写数据的时候，会收到 reset 报文。 再次写的时候会抛出 Broken pipe。
**规则：**当一个进程向某个已经收到 RST 的套接字执行写操作时，内核向该进程发送一个 SIGPIPE 信号。该信号的默认行为是终止进程，因此进程必须捕获它以免不情愿地被终止。 <br/>
不论该进程捕获了该信号并从其信号处理函数返回，还是简单地忽略该信号，写操作都将返回 EPIPE 错误。<br/>
处理 SIGPIPE 的建议方法取决于它发生时应用想做什么。 如果没有特别的事情要做，那么将信号处理程序直接设置为 SIG_IGN 并假设后续的输出操作将捕捉EPIPE错误并终止。如果信号出现时，需采取特殊措施（可能需在日志文件中登记），那么就必须捕获该信号，以便在信号处理函数中执行所有期望的动作。但是必须意识到，如果我们确实需要知道哪个 write 出了错，那么必须要么不理会该信号，要么从信号处理函数返回后再处理来自write的EPIPE. <br/>
**注：** 如果捕获或者忽略 SIGPIPE 信号 那么第二次写操作返回值 -1， 并将 errno 设置为 EPIPE. `strerr` 和 `perror` 函数将 EPIPE 错误报告为： `Broken pipe`。 总的来说，一个健壮的服务器必须捕获这些 SIGPIPE 信号，并且检查 write 函数调用是否有 EPIPE错误。 


## 静态链接库，动态链接库与链接
链接(linking) 是将各种代码和数据部分收集起来并组合成为一个单一文件的过程。 这个文件可被加载（或被拷贝）到存储器并执行。
1. 链接可以执行于编译时（compile time）， 也就是源代码被翻译成机器代码时。
2. 链接可以执行于加载时（load time）， 也就是在程序被加载器（loader）加载到存储器并执行时；
3. 链接也可以执行于运行时（run time）, 由应用程序来执行。 

### 静态库与动态库
**目标文件：** Linux/Unix 中目标文件有三种形式：
- 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。 
- 可执行目标文件。 包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行。 
- 共享目标文件。 一种特殊类型的可重定位目标文件，可以在加载或运行时被动态地加载到存储器并链接。 
<br/>

可以把可重定位的目标模块（文件）进行存档(archive), 生成一个单独的文件，称为**静态库（static library）**. 例如有两个 .c 源文件： addvec.c 和 multvec.c 现在把它们存档成一个静态库： libvector.a。可以执行以下命令：<br/>
```
gcc -c addvec.c multvec.c
ar rcs libvector.a addvec.o multvec.o
``` 
动态库也称为**共享库（shared library）**. 例如有两个 .c 源文件： addvec.c 和 multvec.c 现在把它们链接成一个共享库： libvector.so。可以执行以下命令：<br/>
```
gcc -shared -fPIC -o libvector.so addvec.c multvec.c
```
其中， `-fPIC`选项指示编译器生成与位置无关的代码。 

#### 链接静态库
链接静态库的时机是“编译时”， 静态链接主要做了两部分工作： 符号解析和重定位。 
链接器解析引用的时候建立了三个集合： 
- E,可重定位目标文件的集合； 
- U,一个为解析的符号（引用了尚未定义的符号）的集合；
- D,在前面输入文件中已定义的符号集合。 
（详细的符号解析过程参考CSAPP-链接，此处省略几百字），，，
因此关于库的一般准则就是： 将它们放在命令行的结尾。如果需要满足依赖需求，可以在命令行上重复库。 


#### 动态链接
1. 当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。注意这个过程中，除了一些重定位和符号表信息，没有任何代码和数据拷贝到可执行文件中。 
2. 应用程序还可以在它运行时要求动态链接器加载和链接任意共享库，而无需在编译时连接那些库到应用中。 使用 `dlopen`函数加载和链接共享库。 
```
#include <dlfcn.h>
void* dlopen(const char *filename, int flag);
// 返回：若成功则为指向句柄的指针，若出错则为 NULL. 
```
flag 参数要么是 RTLD_NOW, 该标志告诉链接器立即解析对外部符号的引用，要么包括 RTLD_LAZY 标志，该标志告诉链接器推迟符号解析直到执行来自库中的代码。 

### 目标文件格式
1. 可重定位目标文件
```
			ELF 头
			.text
			.rodata
			.data
			.bass
			.symtab
			.rel.text
			.debug 		// 调试符号表
			.line
			.strtab
			节头部表
```

2. 可执行目标文件
```
			ELF 头部
			段头部表	// 到存储器的映射关系
			.init 		// 程序初始化
			.text
			.rodata
			.data
			.bass
			.symtab
			.debug
			.line
			.strtab
			节头表
```

#### 处理目标文件的工具
- AR
- STRINGS
- STRIP : 从目标文件中删除符号表信息
- NM : 列出一个目标文件的符号表中定义的符号
- SIZE
- READELF
- OBJDUMP
- LDD


### GCC 常用选项

- `gcc -E`： 预处理
- `gcc -S`: 编译
- `gcc -c`: 汇编
- `gcc ` : 链接/(全过程)
- `gcc -g`: 向生成的ELF文件中添加调试信息
- `gcc -D` : 定义宏
- `gcc -U`： 取消宏
- `gcc -I`: 指定搜索头文件的路径
- `gcc -llibrary`: 连接时搜索由 library 命名的库。
- `gcc -L` : 把指定的目录 dir 加到连接程序搜索库文件的路径表中
- `gcc -static` : 指定使用静态连接
- `gcc -O` : 指定优化级别， 默认为 O2 
- `gcc -shared -fPIC -o `: 创建共享库
- `gcc -fno-common` : 告诉链接器，在遇到多重定义的全局符号时，输出一条警告信息。
- `gcc -Wall` : 开启警告


### gdb 调试

#### 调试已运行的程序：
1. 在 Linux 下用 `ps` 或 `pgrep <program>` 查看正在运行的程序的PID(进程ID), 然后用 `gdb <program> PID`格式，挂接正在运行的程序。 
2. 先用 `gdb <program>` 关联上源代码，并运行 gdb, 在 gdb 中用 `attach`命令来挂接进程 PID, 并用 `detach`来取消挂接的进程。

#### 使程序暂停的方式：
1. 设置和显示断点
```
break _linenum_
break _linenum_ if _condition_
break _function_
break _file:linenum_
break _file:function_
break _*address_
break
info break [n]
info breakpoints [n]
```

2. 设置和显示观察点
```
watch _expr_
rwatch _expr_
awatch _expr_
info breakpoints
info watchpoints
```

3. 设置捕捉点
```
catch _event_
event: 
	signal;		signal _signum_;		throw;		catch;
				start;		exit;		load;		unload; 	
```

#### 调试线程：

```
break <linespec> thread <threadno>
break <linespec> thread <threadno> if _condition_
info threads
```

#### 查看栈信息
```
backtrace
bt
bt <n>
up
down
info frame
frame
```

#### 其他查看命令
```
info line
disassembly func
print/f <expr>
print/x <expr>
print/t <expr>
print/d <expr>
display/i $pc
```

### 如何定位内存泄露
1. 静态分析：
	1. 手动检查
		<1>. 读未初始化的存储器
		<2>. 越界
		<3>. 指针悬挂
		<4>. malloc/free, new/delete, new 数组 / delete[] 不匹配或者混用
		<5>. 分配内存与释放内存之间提前 return. 
		<6>. 申请内存与初始化资源管理类（如智能指针shared_ptr）之间被异常截断。
		<7>. 析构函数因抛出异常而被中断。
	2. 静态代码分析工具


2. 动态分析
	1. mtrace 工具
	2. valgrind 工具

## 异常控制流与信号
### 异常控制流
**异常(exception):** 就是控制流中的突变，用来响应处理器状态中的某些变化。 在处理器中，状态被编码为不同的位和信号。状态变化称为事件。在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做一场表的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作体系子程序（异常处理程序：exception handle）。<br/>

异常可以分为四类： 中断，陷阱，故障和终止。 
- 中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说，它是异步的。 
- 剩下的异常类型（陷阱，故障和终止）是同步发生的，是执行当前指令的结果。我们把这类指令叫做故障指令（faulting instruction）。<br/> **陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。**<br/>
**系统调用运行在内核模式中，内核模式允许系统调用执行所有指令，并且可以访问在内核中的栈。**<br/>
**所有到Linux系统调用的参数都是通过寄存器而不是栈传递的。** <br/>

**进程：** 就是一个执行中的程序的实例。由内核来调度和维护，有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显示的[IPC机制]()。 系统中的每个程序都是运行在某个进程的上下文中的。 上下文是由程序正确执行所需的状态组成的。这个状态包括存放在存储器中的程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量以及打开的文件描述符的集合。 <br/>

进程提供给应用程序两个关键的抽象：
1. 一个独立的逻辑控制流；它提供一个假象，好像我们的程序独占地使用处理器。 
2. 一个私有的地址空间；它提供一个假象，好像我们的程序独占地使用存储器系统。

进程从用户模式变为内核模式的唯一方法是通过诸如中断，故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。异常处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。 


### 信号
**信号**就是一条短消息，它通知进程系统中发生了一个某种类型的事件。 每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。 <br/>

发送信号到目的进程是由两个步骤组成的：
1. 发送信号。 内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。 发送信号可以有如下两个原因：
	- 内核检测到一个系统事件，比如被零除错误或者子进程终止。
	- 一个进程调用 kill 函数， 显式地要求内核发送一个信号给目的进程。 一个进程可以发送信号给它自己。 
2. 接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序的用户层函数捕获这个信号。 一个只发出而没有被接收的信号叫做待处理信号。 在任何时刻，一种类型至多只会有一个待处理信号。 <br/>	

一个待处理信号最多只能被接收一次。内核为每个进程在 pending 位向量中维护着待处理信号的集合，而在 blocked 位向量中维护着被阻塞信号集合。 只要传送了一个类型为 k 的信号， 内核就会设置 pending 中的第 k 位，而只要接收了一个类型为 k 的信号，内核就会清除 pending 中的第 k 位。 <br/>

**接收信号的过程：**
当内核从一个异常处理程序返回，准备将控制传递给进程 p 时， 它会检查进程 p 的未被阻塞的待处理信号的集合（pending &~ blocked）， 如果这个集合为空（通常情况下），那么内核将控制传递到 p 的逻辑控制流中的下一条指令。 
然而，如果集合是非空的，那么内核选择集合中的某个信号 k (通常是最小的 k), 并强制 p 接收信号 k. 收到这个信号会触发进程的某个行为。一旦进程完成了这个行为，那么控制就传递回 p 的逻辑控制流中的下一条指令(Inext)。 
<br/>
每个信号类型都有一个预定义的默认行为，是下面中的一种：
- 进程终止
- 进程终止并转储存储器（dump core）
- 进程停止直到被SIGCONT 信号重启
- 进程忽略该信号


**进程可以通过signal 函数修改和信号相关联的默认行为。唯一的例外是 SIGSTOP 和 SIGKILL, 它们的默认行为是不能被修改的。**

<br/>
**信号处理问题**
- 待处理信号不会排队等待。任意类型至多只有一个待处理信号。 
- 系统调用可以被中断。 

[内核是如何发送信号到应用进程的](http://chenwenke.cn/blog/2017/07/06/core-send-signals-to-process/)

### 文件
在 Unix 中， 所有的 I/O 设备， 如网络，磁盘，终端，都被模型化为文件， 而所有的输入和输出都要被当作对相应文件的读和写来执行。 

- **打开文件。** 一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。 内核返回一个小的非负整数，叫描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 

- **改变当前文件的位置。** 对于每个打开的文件，内核保持着一个文件位置 k, 被初始化为 0. 这个文件位置是从文件开头起始的字节偏移量。 应用程序能够通过执行 seek 操作，显式地设置文件的当前位置为 k。 

- **关闭文件。** 当应用完成了对文件的访问之后，它就通知内核关闭这个文件。 作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的文件描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的存储器资源。


某些情况下， read 和 write 传送的字节比应用程序的要求的要少。这些不足值不表示有错误。出现这种情况的原因如下：
- 读时遇到 EOF。 
- 从终端读文本行。
- 读和写网络套接字。 如果打开的文件对应于网络套接字，那么内部缓冲约束和较长的网络延迟会引起 read 和 write 返回不足值。 对管道调用 read 和 write时， 也有可能出现不足值。 

实际上，除了 EOF, 你在读磁盘文件时将不会遇到不足值，而且在写磁盘文件时，也不会遇到不足值。 然而如果你想要创建健壮的（可靠的）诸如Web服务器这样的网络应用，就必须反复调用 read 和 write 处理不足值，直到所有的字节都传送完毕。 

#### 打开文件的数据结构
**内核用三个相关的数据结构来表示打开的文件。**

- 描述符表。 每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。 每个打开的描述符表项指向文件表中的一个表项。

- 文件表。 打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成（针对我们的目的）包括有当前的文件位置，引用计数（即当前指向该表项的描述符表项数），以及一个指向 v-node 表中对应表项的指针。 关闭一个描述符会减少相应的文件表表项中的引用计数。 内核不会删除这个文件表表项，直到它的引用计数为零。

- v-node 表。 同文件表一样，所有的进程共享这张 v-node 表。 每个表项包含 stat 结构中的大多数信息， 包括 st-mode 和 st-size成员。


在调用 fork 后， 子进程有一个父进程描述符表的副本。父子进程共享相同的打开文件表集合，因此共享相同的文件位置。（一个很重要的结果就是，在内核删除相应文件表表项之前，父子进程必须都关闭了它们的描述符。）

![打开文件的数据结构]()

#### 标准IO与文件IO

**文件I/O：**  文件I/O称之为不带缓存的I/O（unbuffered I/O)。不带缓存指的是每个read，write都调用内核中的一个系统调用。也就是一般所说的低级I/O——操作系统提供的基本IO服务，与os绑定。

标准I/O： 标准I/O是ANSI C建立的一个标准I/O模型，是一个标准函数包和stdio.h头文件中的定义，具有一定的可移植性。标准I/O库处理很多细节。例如缓存分配，以优化长度执行I/O等。标准的I/O提供了三种类型的缓存。
- 全缓存
- 行缓存
- 不缓存

标准I/O库将一个打开的文件模型化为一个流。 对于程序员而言，一个流就是一个指向FILE类型的结构指针。 <br/>
类型为FILE的流是对文件描述符和流缓冲区的抽象。流缓冲区的目的是为了减少开销较高的Unix I/O系统调用的数量。 

[标准IO VS 文件IO](http://chenwenke.cn/blog/2017/05/05/fileIO-VS-standardIO/)


### 守护进程
守护进程(daemon)是后台运行且不与任何控制终端关联的进程。守护进程的生存期一般都很长，它们常常在系统引导装入时启动，仅仅在系统关闭时才终止。

另外，应当注意的是用户层的守护进程的父进程都是 init进程。
#### 守护进程的编程规则：
1. 首先要做的是调用 umask 将文件模式创建屏蔽字设置为一个已知值（通常是 0）.
2. 调用 fork，然后使父进程 exit. 使得当前进程的父进程是 init 进程。
3. 调用 setsid创建一个新会话。 
4. 调用 fork， 然后使父进程 exit. 使得当前进程不是该会话里的首进程，因而不会和终端相联。 
5. 更改当前工作目录为根目录（或其他目录，一般是根目录）
6. 关闭不再需要的文件描述符。
7. 如果有输入输出，重定向文件描述符0，1，2到文件/dev/null。  





