## C++ 相关知识点

### 结构体字节对齐
字节对齐的细节和编译器相关，但一般而言，满足三个准则。 
1. 结构体变量的首地址能够被其最宽基本类型成员的大小所整除。 
2. 结构体每个成员相对于结构体首地址的偏移量都是该成员大小的整数倍。
3. 结构体总大小为结构体最宽基本类型成员大小的整数倍。 

当需要以指定的字节进行对齐时，可以使用预编译命令： `#pragma pack(2) // 2字节对齐`

### 析构函数
当下列事件之一放生时，将调用析构函数。
- 使用 delete 运算符显式解除了分配了使用 new 运算符分配的对象。
- 具有块范围的本地（自动）对象超出范围。
- 临时对象生存期结束。 
- 程序结束，并且存在全局或静态对象。 
- 使用析构函数的完全限定名显式调用了析构函数。 

从析构函数调用虚函数时，调用的函数是当前正在销毁的类的函数。 <br/>

析构函数有两个限制：
- 你无法采用析构函数的地址。
- 派生类不会继承基类的析构函数，它们总是重写。

析构的顺序：
1. 将调用该类的析构函数，并且会执行该析构函数的主体。
2. 按照非静态成员对象的析构函数在声明中显示顺序的相反顺序调用这些函数，用于这些函数成员的构造的可选成员优化列表不影响构造或析构的顺序。
3. 非虚基类的析构函数以声明的相反顺序被调用。
4. 虚拟基类的析构函数以声明的相反顺序被调用。 
5. 程序结束时，调用静态成员和全局变量的析构函数。

### 类对象的内存存储形式
1. 静态成员存储在全局静态区
2. 如果有虚函数或虚继承了基类，虚表指针一般放在对象开始位置（为了加快效率）。 
3. 如果没有虚继承，非静态类极其成员会按照继承的声明顺序依次存放。
4. 如果有虚继承，虚继承的类一般存放在最后。

- [常见C++面试题总结](http://www.cnblogs.com/LUO77/p/5771237.html)
- [C++对象的内存布局](https://coolshell.cn/articles/12176.html)

### 虚函数
虚函数是声明时带 virtual 关键字的成员函数， 声明虚函数的类一般都是要作为基类的，像把有些函数的接口传递给派生类实现，并且是在运行时决定调用哪个具体函数。 虚函数分两种，一般虚函数和纯虚函数。 一般虚函数通常在基类中有一份实现，然后这份实现作为这个虚函数接口的缺省实现传递给所有继承它的子类。 纯虚函数是是带`=0`的虚函数。拥有一个或多个纯虚函数的类叫做抽象类，不允许有实例对象。纯虚函数在基类中通常没有实现代码。 <br/>
虚函数的实现是通过一个函数指针数组（虚函数表）和一个指向这个数组的指针，虚函数指针实现的。带有虚函数的类的实例对象内部最少有一个虚函数指针，指向这个类的虚函数表。多继承的时候可能有多个虚函数指针，多个虚函数表。 

- [C++虚函数表解析](https://coolshell.cn/articles/12165.html)

**注意事项：**
- 拥有虚函数的类析构函数一定要声明成虚函数。
- 构造函数和析构函数内不要调用虚函数。
- 派生类中对基类中的虚函数的重写或实现，声明式一定要严格匹配。 
- 派生类对基类中的虚函数重写和实现时，不要重新定义继承来的缺省值。 

### C 程序内存布局

```
		内核区
	环境变量字符串
	命令行字符串
	环境变量指针
	命令行参数指针
	argc命令行参数个数
		栈
		共享库
		堆
		.BSS区
		初始化数据区
		Text区
```

### volatile 关键字
volatile 的确切含义与机器有关，只能通过阅读编译器文档来理解。
关键字 volatile 告诉编译器不应对这样的对象进行优化。在使用用 volatile 声明的变量的时候，系统总是从它所在的内存读取数据，即使前面的指令刚刚从该处读取过数据，而且读取的数据立即被保存。 即系统对volatile对象不做寄存器缓存。 这样在多线程中，就可以避免因为一个线程从内存中读写 volatile 对象，另一个线程从寄存器中读写 volatile 对象从而出现不一致的现象。但是这并不是说 volatile 修饰的变量是线程安全的， 在 volatile 对象的大小大于数据线的宽度的时候（64的机器数据线是64bit, 32位的机器数据线是32bit）， 如果有两个或两个以上的线程同时读写同一个volatile 对象，可能会发生数据的切割。 所以说只有 volatile对象小于数据线宽度的时候，才是线程安全的。

另外，全局变量，静态变量和volatile修饰的易失变量都不受优化的影响，在 longjmp之后，它们的值是最近所呈现的值。 

**规则：**
- 只有 volatile 的成员函数才能被 volatile 的对象调用。
- 和 const 一样，我们只能将一个 volatile 对象的地址（或者拷贝一个指向 volatile类型的指针）赋给一个指向 volatile 的指针。 同时，只有当某个引用是 volatile 时，我们才能使用一个 volatile 对象初始化该引用。
- const 和 volatile 的一个重要区别是我们不能使用合成的拷贝/移动构造函数以及赋值运算符初始化 volatile对象或从volatile对象赋值。

### extern "C" --- 链接指示
其他语言中的函数名字也必须在C++中进行声明，并且该声明必须指定返回类型和形参列表。对于其他语言编写的函数来说，编译器检查其调用方式与处理普通C++函数的方式相同，但是生成的代码有所区别。

例如在C++语言里面有函数重载的概念，而 C 语言里没有重载的概念。 所以对同一个函数名的修饰，C和C++是不一样的。 例如：
```
void func(int a, int b)
{
	// TODO:
}
```
C 语言里的修饰可能是： func, 而C++中的修饰需要标记出参数列表信息， 例如： func_int_int。 链接指示`extern "C"`就是要把 链接指示下的代码生成C++风格的目标文件。 
同理除了重载，C++还需要对类内成员进行跟C语言不一样的额外处理。 

### 指针与引用的区别

- 指针是一个变量，只不过这个变量存储的是一个地址，指向内存中的一个存储单元； 而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。 
- 指针可以有多级，但是引用只能有一级。 
- 指针的值可以为空，但是引用的值不能为 NULL, 并且引用在定义的时候必须初始化。 
- 指针的值在初始化后可以改变，即指向其他的存储单元。而引用在进行初始化后就不会再改变了。
- sizeof作用于引用得到的是所指向变量（对象）的大小， 而 sizeof作用于指针得到的则是指针本身的大小。
- 指针和引用的自增（++）运算意义不一样。
- 指针传参的时候，还是值传递，试图修改传进来的指针的值是无意义的，只能修改地址所保存变量的值。引用传参的时候，传进来的就是变量本身，因此可以被修改。


### new/delete 与 malloc/free 的区别

1. new 从[自由存储区](http://chenwenke.cn/blog/2017/06/07/memory-areas-in-c++/)分配内存； malloc 从堆区分配内存。

2. new 返回一个全类型的指针；malloc 返回一个 void* 类型的指针。 

3. new 在内存不够时，抛出 bad_alloc 异常；malloc 在内存不够时，返回 NULL。 

4. new 的传入参数是类型 ID，大小由编译器计算。malloc 需要自行计算要分配的字节。 

5. new 有一个专门处理数组的版本；malloc 没有。 

6. new/delete 在内存分配后随即调用相应类型的构造函数初始化内存，在释放内存之前会先调用相应类型的析构函数；malloc/free 只是简单的申请/释放内存，不做初始化构造操作。 

7. new/delete 运算符能够被重载。 malloc/free不能。

8. new 内存扩充时，由于拷贝构造函数的原因，语义不太明显，有点反直觉；malloc重新分配内存时，比较简单直观。

9. new 可以添加一个内存分配器，处理 low memory. 也就是 定位new, 从特定位置分配内存；malloc 没有这项技能。 

10. new/delete 可能是/也可能不是由 malloc/free 实现的，取决于编译器。

### 引用的好处

1. 引用就是一个对象的别名，并不另外占用空间，使用时必须初始化，而且中途不能更改。 由于引用本身不是一个变量，所以没有指向引用的指针，也没有指向引用的引用。

2. 有时使用引用非常高效，例如自定义的对象和非内置的对象和模板，传参时常用 const-by-reference. 可以说，引用是指向内存中的同一份对象，因此省去了构造一份副本的时间消耗和空间消耗。但对于简单的内置类型如：int, double, 指针这些类型，值拷贝的成本很小，使用引用反而会因为降低程序的空间局部性，从而可能降低程序的执行效率。

3. 有些类型允许被拷贝，只能使用引用或指针，如输入，输出流，因为它们的缓冲区只有一份，不允许被拷贝。

4. 连续操作符号，拷贝赋值运算符一般返回的是指向 this 的引用。

**禁忌：**
1. 不要返回指向 local stack对象的引用或指针。
2. 不要返回指向 heap-allocated对象的引用。
3. 不要返回指向 local static 对象的引用或指针，而有可能同时需要多个这样的对象。


### 有那几种情况只能使用初始化列表（initialization list）而不能用赋值（assignment）
当类中含有 const 或引用成员变量时，以及调用基类的构造来初始化基类部分时。都需要初始化表。 
C++ 中规定，对象的初始化是在进入构造函数体之前完成的。 

#### const 的好处：
1. 使用 const 代替宏，使得编译错误更加明显已读。
2. 生成的ELF文件可能更小。
3. 可以定义类内常量，把作用域限定在类内，防止命名冲突。

const 应用广泛，可修饰 global 变量，命名空间内的变量，普通变量，静态变量，指针前，指针后。返回值，参数甚至成员函数本体。


### 内联函数
inline 函数通常一定被置于头文件内，因为大多数编译环境在编译过程中进行 inline, 而为了将一个“函数调用”替换为“被调用函数的本体”，编译器必须知道那个函数长什么样子。 

内联函数分为显示内联和隐式内联。 在类的声明文件里，直接实现的简单函数是隐式内联的。

#### 内联函数的优点：
1. 语境最优化，更小，更快。 
2. 对于内联函数的每一个调用，都以函数本体替换。没有过程调用时压栈，退栈的开销。

#### 内联函数的缺点：
1. 代码膨胀造成额外的换页。
2. 二进制升级问题。
3. 大部分调试器对内联函数无能为力。（毕竟你不能在不存在的函数内设置断点）。

另外，构造和析构函数一般是内联函数的糟糕候选者，因为编译器隐含地为构造函数和析构函数编写了很多代码。 内联只是一个申请，并不是一个强制命令。循环，递归，取函数指针，虚函数一般都会使内联落空。 



### [Effective C++ 读书笔记](https://github.com/CaoTanXiaoKe/CodingNotes/tree/master/cpp/EffecticeCpp)

### STL 容器

常会考察的： 
- map/set: 红黑树
- unordered_map/unordered_set: 链式Hash
- vector: 动态数组（注意内存扩充方式）
- string: 需要会简单实现（注意拷贝赋值函数的异常安全）

不常被考察但常用的： 
- multiset/multimap
- list: 双向链表
- queue: 队列
- priority_queue
- stack： 栈
- deque: 单调队列

### 模板特化

