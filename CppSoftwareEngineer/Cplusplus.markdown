## C++ 相关知识点

### 结构体字节对齐
字节对齐的细节和编译器相关，但一般而言，满足三个准则。 
1. 结构体变量的首地址能够被其最宽基本类型成员的大小所整除。 
2. 结构体每个成员相对于结构体首地址的偏移量都是该成员大小的整数倍。
3. 结构体总大小为结构体最宽基本类型成员大小的整数倍。 

当需要以指定的字节进行对齐时，可以使用预编译命令： `#pragma pack(2) // 2字节对齐`

### 析构函数
当下列事件之一放生时，将调用析构函数。
- 使用 delete 运算符显式解除了分配了使用 new 运算符分配的对象。
- 具有块范围的本地（自动）对象超出范围。
- 临时对象生存期结束。 
- 程序结束，并且存在全局或静态对象。 
- 使用析构函数的完全限定名显式调用了析构函数。 

从析构函数调用虚函数时，调用的函数是当前正在销毁的类的函数。 <br/>

析构函数有两个限制：
- 你无法采用析构函数的地址。
- 派生类不会继承基类的析构函数，它们总是重写。

析构的顺序：
1. 将调用该类的析构函数，并且会执行该析构函数的主体。
2. 按照非静态成员对象的析构函数在声明中显示顺序的相反顺序调用这些函数，用于这些函数成员的构造的可选成员优化列表不影响构造或析构的顺序。
3. 非虚基类的析构函数以声明的相反顺序被调用。
4. 虚拟基类的析构函数以声明的相反顺序被调用。 
5. 程序结束时，调用静态成员和全局变量的析构函数。

### 类对象的内存存储形式
1. 静态成员存储在全局静态区
2. 如果有虚函数或虚继承了基类，虚表指针一般放在对象开始位置（为了加快效率）。 
3. 如果没有虚继承，非静态类极其成员会按照继承的声明顺序依次存放。
4. 如果有虚继承，虚继承的类一般存放在最后。

- [常见C++面试题总结](http://www.cnblogs.com/LUO77/p/5771237.html)
- [C++对象的内存布局](https://coolshell.cn/articles/12176.html)

### 虚函数
虚函数是声明时带 virtual 关键字的成员函数， 声明虚函数的类一般都是要作为基类的，像把有些函数的接口传递给派生类实现，并且是在运行时决定调用哪个具体函数。 虚函数分两种，一般虚函数和纯虚函数。 一般虚函数通常在基类中有一份实现，然后这份实现作为这个虚函数接口的缺省实现传递给所有继承它的子类。 纯虚函数是是带`=0`的虚函数。拥有一个或多个纯虚函数的类叫做抽象类，不允许有实例对象。纯虚函数在基类中通常没有实现代码。 <br/>
虚函数的实现是通过一个函数指针数组（虚函数表）和一个指向这个数组的指针，虚函数指针实现的。带有虚函数的类的实例对象内部最少有一个虚函数指针，指向这个类的虚函数表。多继承的时候可能有多个虚函数指针，多个虚函数表。 

- [C++虚函数表解析](https://coolshell.cn/articles/12165.html)

**注意事项：**
- 拥有虚函数的类析构函数一定要声明成虚函数。
- 构造函数和析构函数内不要调用虚函数。
- 派生类中对基类中的虚函数的重写或实现，声明式一定要严格匹配。 
- 派生类对基类中的虚函数重写和实现时，不要重新定义继承来的缺省值。 

### C 程序内存布局

```
		内核区
	环境变量字符串
	命令行字符串
	环境变量指针
	命令行参数指针
	argc命令行参数个数
		栈
		共享库
		堆
		.BSS区
		初始化数据区
		Text区
```

### 指针与引用的区别

- 指针是一个变量，只不过这个变量存储的是一个地址，指向内存中的一个存储单元； 而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。 
- 指针可以有多级，但是引用只能有一级。 
- 指针的值可以为空，但是引用的值不能为 NULL, 并且引用在定义的时候必须初始化。 
- 指针的值在初始化后可以改变，即指向其他的存储单元。而引用在进行初始化后就不会再改变了。
- sizeof作用于引用得到的是所指向变量（对象）的大小， 而 sizeof作用于指针得到的则是指针本身的大小。
- 指针和引用的自增（++）运算意义不一样。
- 指针传参的时候，还是值传递，试图修改传进来的指针的值是无意义的，只能修改地址所保存变量的值。引用传参的时候，传进来的就是变量本身，因此可以被修改。


### volatile 关键字
volatile 的确切含义与机器有关，只能通过阅读编译器文档来理解。
关键字 volatile 告诉编译器不应对这样的对象进行优化。在使用用 volatile 声明的变量的时候，系统总是从它所在的内存读取数据，即使前面的指令刚刚从该处读取过数据，而且读取的数据立即被保存。 即系统对volatile对象不做寄存器缓存。 这样在多线程中，就可以避免因为一个线程从内存中读写 volatile 对象，另一个线程从寄存器中读写 volatile 对象从而出现不一致的现象。但是这并不是说 volatile 修饰的变量是线程安全的， 在 volatile 对象的大小大于数据线的宽度的时候（64的机器数据线是64bit, 32位的机器数据线是32bit）， 如果有两个或两个以上的线程同时读写同一个volatile 对象，可能会发生数据的切割。 所以说只有 volatile对象小于数据线宽度的时候，才是线程安全的。

另外，全局变量，静态变量和volatile修饰的易失变量都不受优化的影响，在 longjmp之后，它们的值是最近所呈现的值。 

**规则：**
- 只有 volatile 的成员函数才能被 volatile 的对象调用。
- 和 const 一样，我们只能将一个 volatile 对象的地址（或者拷贝一个指向 volatile类型的指针）赋给一个指向 volatile 的指针。 同时，只有当某个引用是 volatile 时，我们才能使用一个 volatile 对象初始化该引用。
- const 和 volatile 的一个重要区别是我们不能使用合成的拷贝/移动构造函数以及赋值运算符初始化 volatile对象或从volatile对象赋值。

### extern "C" --- 链接指示
其他语言中的函数名字也必须在C++中进行声明，并且该声明必须指定返回类型和形参列表。对于其他语言编写的函数来说，编译器检查其调用方式与处理普通C++函数的方式相同，但是生成的代码有所区别。

例如在C++语言里面有函数重载的概念，而 C 语言里没有重载的概念。 所以对同一个函数名的修饰，C和C++是不一样的。 例如：
```
void func(int a, int b)
{
	// TODO:
}
```
C 语言里的修饰可能是： func, 而C++中的修饰需要标记出参数列表信息， 例如： func_int_int。 链接指示`extern "C"`就是要把 链接指示下的代码生成C++风格的目标文件。 
同理除了重载，C++还需要对类内成员进行跟C语言不一样的额外处理。 


### [Effective C++ 读书笔记]()




### STL 容器




