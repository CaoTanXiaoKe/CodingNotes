<br>
<font size = 4; background-color: #fffefb;>
>  The biggest speedup you’ll ever get with a program will be when you first get it working.<br>
>你能获得的对程序最大的加速比就是当你第一次让它工作起来的时候。<br>
—John K. Ousterhout
<br>

<br>

* 当然， 一个**程序首先要能运行起来**。 即使是姿势再丑， 再笨拙，屌丝气十足的 暴力遍历  也聊胜于无啊。 <br><br>
* 选择**一组合适的算法和数据结构。**算法和数据结构是程序的**灵魂**。  <br><br>
* **编写出编译器能够有效优化以转换成高效可执行代码的源代码。**  对于这一点， 理解编译器的一些基本能力， 特性以及局限性真的很总要。 编写程序方式中看上去只是一点小小的变动， 都会引起编译器优化方式很大的变化。 由于编译器原理很复杂， 各个编译器， 以及优化层次选择的不同， 优化方式可能有很大的变化。 所以，想要编写出精致高效的代码， 良好的风格以及不断的经验积累才是王道。 <br><br>
* 针对处理运算量特别大的计算， 将一个任务分成多个部分， 这些部分可以在多核和多处理器的某种组合上并行的计算---- ** 多线程并行算法 ** 。<br> <br>

> 程序员必须在实现和维护程序的简单性与它的运行速度之间做出权衡。

<br><br>

**具体方法**
<br><br>
* 掌握常用的高效的数据结构和算法。 至少要熟悉模板的使用。
* 消除循环的低效率， 尽量减少循环次数。 尽量不要在循环里 循环计算一些不会改变的值。 <br><br>
* 消除不必要的**存储器引用**。 尽量使用临时变量来暂存要多次使用的引用值，避免寻址开销。 <br><br>
* **防止寄存器溢出**。 临时变量也并不是越多越好， 因为寄存器总是有限的，如果需要同时使用的临时变量数超过了可用的寄存器数量，编译器会把临时值存放到栈中。 一旦出现这种情况， 性能会急剧下降。（x86-64代码能够同时累积最多 12 个值， 而不会溢出任何寄存器。）<br><br>
*  循环展开。 通俗的说就是利用分治的策略来减小循环的迭代次数。 <br><br>
* 提高**并行性**。 大多数情况下，程序的代码都不是按部就班的一步一步从上往下执行的， 它会适当的并行一些不相依赖的代码行。 所以尽量编写不相依赖的代码， 能够提高运行效率。
* **编写利于分支预测的代码。** 在 CPU 执行分支时， 会预测程序朝哪一个分支方向执行。 如果预测错误会被罚时。 
处理方法一般是(1): 编写能被预测的分支。 （2）：书写条件传送实现的代码， 不依赖分支预测。  
<br>
<br>
<font color:pink>未完待续 ~~~ </font>
* 参考资料：《深入理解计算机系统》
</font>
<br>
