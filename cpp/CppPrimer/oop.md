### 面向对象设计
---

面向对象程序设计基于三个基本概念： **数据抽象**，**继承**和**动态绑定。**


##### 继承和动态绑定对程序编程有两方面的影响：

1. 我们可以更容易地定义与其他类相似但不完全相等的新类；
2. 在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略它们的区别。 

##### 动态绑定

函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又称为**运行时绑定(run-time binding)**。 动态绑定是由C++的虚函数机制实现的。 

在 C++ 语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。 

**Best Practice:** 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。 

**Note:** 在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。 

派生类必须使用基类的构造函数来初始化他的基类部分。 

**Note:** 每个类控制它自己的成员初始化过程。 

**Note:** 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。 

> **关键概念：遵循基类的接口**<br/>
必须明确一点：每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。 <br/>
因此，派生类对象不能直接初始化基类成员。尽管从语法上说我们可以在派生类构造函数体内给它公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。 

**理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在。**

**Note： 和内置指针一样，智能指针也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。**

**Note: 在对象之间不存在类型转换，有时派生对象看似能够转换为它的基类的原因是：拷贝构造函数是使用引用的。**

 当我们用一个派生类对象为一个基类对象初始化或赋值时, 只有该派生类对象中的基类部分会被拷贝，移动或赋值，它的派生类部分将被忽略掉。 

> **关键概念：存在继承关系的类型之间的转换规则**<br/>
* 从派生类向基类的类型转换只对指针或引用类型有效。 
* 基类向派生类不存在隐式类型转换。 
* 和任何其他类型一样，派生类向基类类型的转换也可能会由于访问受限而变得不可行。 


> **关键概念：C++的多态性**
OOP的核心思想是多态性(polymorphism)。 我们把具有继承关系的多个类型称为多态类型，引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本所在。 

**Note:** 当且仅当通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。 

**Note:** 基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。 

虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。 
换句话说，如果我们通过基类的引用或指针调用函数，则使用基类定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。 

**Best Practices:** 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。 

> **关键概念：重构**<br/>
重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。 对于面向对象的应用程序来说，重构是一种很普遍的现象。

**Note:** 派生类的成员将隐藏同名的基类成员。 

**Best Practices:** 除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。 

**名称查找先于类型检查**： 正如声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义派生类中的函数也不会重载其基类中的成员。和其他作用域一样，如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉； 


