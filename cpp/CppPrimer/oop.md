### 面向对象设计
---

面向对象程序设计基于三个基本概念： **数据抽象**，**继承**和**动态绑定。**


##### 继承和动态绑定对程序编程有两方面的影响：

1. 我们可以更容易地定义与其他类相似但不完全相等的新类；
2. 在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略它们的区别。 

##### 动态绑定

函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又称为**运行时绑定(run-time binding)**。 动态绑定是由C++的虚函数机制实现的。 

在 C++ 语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。 

**Best Practice:** 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。 

**Note:** 在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。 

派生类必须使用基类的构造函数来初始化他的基类部分。 

**Note:** 每个类控制它自己的成员初始化过程。 

**Note:** 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。 

> **关键概念：遵循基类的接口**<br/>
必须明确一点：每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。 <br/>
因此，派生类对象不能直接初始化基类成员。尽管从语法上说我们可以在派生类构造函数体内给它公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。 

**理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在。**

**Note： 和内置指针一样，智能指针也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。**

**Note: 在对象之间不存在类型转换，有时派生对象看似能够转换为它的基类的原因是：拷贝构造函数是使用引用的。**

 当我们用一个派生类对象为一个基类对象初始化或赋值时, 只有该派生类对象中的基类部分会被拷贝，移动或赋值，它的派生类部分将被忽略掉。 

> **关键概念：存在继承关系的类型之间的转换规则**<br/>
* 从派生类向基类的类型转换只对指针或引用类型有效。 
* 基类向派生类不存在隐式类型转换。 
* 和任何其他类型一样，派生类向基类类型的转换也可能会由于访问受限而变得不可行。 
