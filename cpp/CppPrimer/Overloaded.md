## 重载的基本概念

**除了重载的函数调用运算符 operator() 之外， 其他重载运算符不能含有默认实参。** 

> 对于一个运算符函数来说， 它或者是类的成员，或者至少含有一个类类型的参数。 

因为重载运算符相当于相应的函数调用，所以某些指定了运算对象求值顺序无法保留下来。 
特别是： 逻辑与，或运算符， 逗号运算符。 
另外，C++语言已经定义了逗号运算符和取地址运算符作用于类的含义，所以一般情况下也不建议重载。 

> **Best Practices: 通常情况下，不应该重载逗号，取地址，逻辑与和逻辑或运算符。**

建议： 只有当操作的含义对于用户来说清晰明了时才使用运算符。如果用户对运算符可能有几种不同的理解，则使用这样的运算符将产生二义性。 

#### 选择作为成员或者非成员的准则

- 赋值(=)， 下表([])，调用(()) 和成员访问箭头(->)运算符必须是成员。 

- 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。 

- 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增，递减和解引用运算符，通常应该是成员。 

- 具有对称性的运算符可以转换任意一端的运算对象，例如算术，相等性，关系和位运算符等。因此它们通常应该是普通的非成员函数。 

> **Best Practices: 通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。**

**Note: 输入运算符必需处理输入可能失败的情况，而输出运算符不需要。** 

> **Best Practices: 当读取操作发生错误时，输入运算符应该负责从错误中恢复。**

通常情况下，我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变对象的状态，所以形参都是常量的引用。 

如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。 

> **Best Practices: 如果某个类在逻辑上有相等性的含义，则该类应该定义 operator==, 这样做可以使得用户更容易使用标准库算法来处理这个类。**

#### 关系运算符

定义了相等运算符的类也常常（但不总是）包含关系运算符。 特别是，因为关联容器和一些算法要用到小于运算符，所以定义 operator< 会比较有用。 

通常情况下关系运算符应该： 
1. 定义顺序关系，令其与关联容器中对关键字的要求一致； 并且
2. 如果类同时也含有==运算符的话，则定义一种关系令其与==保持一致。特别是，如果两个对象是 != 的，那么一个对象应该 < 另一个。 

> **Best Practice: 如果存在唯一一种逻辑可靠的 < 定义，则应该考虑为这个类定义 < 运算符。如果类同时还包括==，则当且仅当<的定义和==产生的结果一致时才定义 < 运算符。**

#### 赋值运算符

我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必需定义未成员函数。 

> **赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。**

#### 下标运算符

为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。 

> **Best Practices: 如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。** 

#### 递增和递减运算符

> **Best Practices: 定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员。**

> **Best Practices: 为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。**

> **Best Practices: 为了与内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。**

#### 成员访问运算符

箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。 

重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。 

#### 类型转换运算符

一个类型转换函数必须是类的成员函数；不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是 const。 

在实践中，类很少提供类型转换运算符。 然而这条经验法则存在一种例外情况：对于类来说，定义向 bool 的类型转换还是比较普遍的现象。 

> **向 bool 的类型转换通常用在条件部分，因此 operator bool 一般定义成 explicit 的*。*



