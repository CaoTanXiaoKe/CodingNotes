## 默认构造函数
编译器创建的构造函数又称为**合成的默认构造函数(synthesized default constructor).**对于大多数类来说，这个合成的默认构造函数按照如下规则初始化类的数据成员。 
1. 如果存在类内的初始值，用初始值初始化响应的数据成员。 
2. 否则，默认初始化该成员。 
	1. 如果内置类型的变量未被显式初始化，它的值由定义的为止决定。 
	2. 每个类各自决定其初始化其对象的方式。 
	3. 一些类要求每个对象都显式初始化。 

**某些类不能依赖于合成的默认构造函数的原因：
1. 只有当类没有声明任何构造函数时，编译器才会自动的生成默认构造函数。 
2. 如果类包含内置类型或复合类型（如引用，指针，数组）的成员，只有当全部都被赋予了类内的初始值时，这个类才适合使用合成的默认构造函数。 
3. 有些时候编译器不能为某些类合成默认的构造函数。 
**注意：**构造函数不应该轻易的覆盖掉类内的初始值，除非新赋的值与原值不同。 如果你不能使用类内初始值，则所有构造函数都应该显式的初始化每个内置类型的成员。 

## 构造函数初始值列表
就对象的数据成员而言，初始值和赋值是有区别的。如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。这时，构造函数的功能相当于给类的数据成员赋值。 (不同于其他成员函数，构造函数不能被声明成 const 的。 当我们创建类的一个 const 对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。 因此，构造函数在 const 对象的构造过程中可以向其写值。) 构造函数的初始值有时是必不可少的，例如：成员是 const 或者是引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。 
**建议：**使用构造函数初始值。 这不仅事关效率的问题，有时还是必须的。 

**Best Practices: 最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且可能的话，尽量避免使用某些成员初始化其他成员。**

**Best Practices: 如果定义了其他构造函数，那么最好也提供一个默认构造函数。**
## 隐式类型转换：
隐式类型转换只允许一步类类型转换，可以用关键字`explicit`抑制构造函数的隐式转换。 另外，关键字`explicit`只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为 explicit 的。 还有，`explicit`只能在类内声明构造函数时使用。 `explicit`构造函数只能用于直接初始化，不能用于拷贝形式的初始化过程。 
**Best Practices: 即使一个常量静态成员在类内部初始化了，通常情况下也应该在类的外部定义一下改成员**  
