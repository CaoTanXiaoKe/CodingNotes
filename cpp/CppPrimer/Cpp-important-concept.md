## C++ 重要知识点

#### 虚函数

虚函数表，虚继承等。

指向虚函数表的指针一般放在一个对象的最前面。 这是为了保证取虚函数表具有最高的性能 -- 如果有多层继承或多重继承的情况。 

1. 一般继承（无虚函数覆盖）
- 虚函数按照其声明顺序放于表中。 
- 父类的虚函数在子类的虚函数前面。 

2. 一般继承（有虚函数覆盖）
- 覆盖的f()函数被放到了虚表中原来父类虚函数的位置。 
- 没有被覆盖的函数依旧。 

3. 多重继承（无虚函数覆盖）
- 每个父类都有自己的虚表。 
- 子类的成员函数被放到了第一个父类的表中。 （所谓的第一个父类时按照声明顺序来判断的）。 

4. 多重继承（有虚函数覆盖）
- 子类覆盖所有父类中的同名虚函数。 
- 没有被覆盖的函数依旧。 

安全性问题：
- 通过父类类型的指针访问子类自己的虚函数。 因为子类自己的虚函数也存在于虚函数表中，所以可以通过指针访问。 
- 访问non-public函数。 如果父类的虚函数是 private 或是 protected的，但这些非public的虚函数同样会存在于虚函数表中， 所以，我们同样可以使用访问虚函数表的方式来访问这些 non-public的虚函数。 

5. 菱形继承。在不使用虚继承的情况下，会出现二义性。 

6. 一般虚继承。 
- 即使只有单继承，也会有两个虚表指针。
- 记录子类虚函数表的指针在前，父类的在后（成员也一样）。 
- 替换规则不变。G++和VC略有不同。 

7. 菱形虚继承。 
- 被虚继承的顶层类的虚表指针，及成员被放到对象的末尾（只有一份）
- 其他规则几乎不变。

#### 对象模型
- static 每个类只有一份。 
- 子类的成员会覆盖父类的同名成员。 
- 成员变量的位置总是紧紧跟在虚表指针后。


**注意：** 在已经有指向虚表的指针时，虚基类指针并不会再显式地占用对象的空间，而是隐式的。 如果没有虚表指针，则会占用一个指针的空间。 

#### 权限控制

public 继承 表示 is-a 的关系。 
private 继承 表示 implemented-in-terms-of（由某物实现出）的关系。 
组合表示 has-a的关系或者 implemented-interms-of的关系。 当面对 private继承和组合的取舍时，优先考虑组合。 

#### const的问题
const int * ptr; 和 int const * ptr;是等价的。意味：指针所指物的内容不变。 
int * const ptr; 意味：指针的指向不能变。 

两个函数如果只是常量性（constness）不同, 可以被重载。 

当 const 和 non-const 成员函数有着实质等价的实现时，令 non-const函数版本调用 const 版本可避免代码重复。  

#### 虚基类和抽象基类
在继承的时候加上 virtual 关键字， 就可以实现虚拟继承。
带有纯虚函数的基类称为虚基类。

polymorphic(带多态性质的) base class 应该声明一个 virtual 析构函数。在构造函数以及析构函数内（及其子函数内）不要调用析构函数。 

析构函数绝对不要吐出异常。 



#### 泛型技术
所谓泛型技术即是试图使用不变的代码来实现可变的“算法”（功能）。 
常用的泛型技术有： 模板技术，RTTI技术， 虚函数技术。 这些技术要么是试图在编译时进行决议，要么是试图做到运行时决议。 



#### 参考资料
- [C++虚函数表解析](http://blog.csdn.net/haoel/article/details/1948051)
- [C++对象的内存布局](http://blog.csdn.net/haoel/article/details/3081328/)
- [图说C++对象模型:对象内存布局详解](http://blog.jobbole.com/101583/)
- 《C++ Primer 5th》
- 《Effective C++ 3th》